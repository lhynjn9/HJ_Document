# Container&Imgage

> #### Container

- 애플리케이션, 웹 사이트, 노드 서버, 애플리케이션을 실행하는 전체 환경 등 무엇이든 포함하는 작은 패키지
- **<u>이미지의 구체적인 실행 인스턴스</u>**(실행 중인 이미지 인스턴스)
- 이미지를 기반으로 함
- 컨테이너를 실행할 수 있도록 이미지를 생성하고 가져오는 2가지 방법이 있음
  1. 이미 존재하는 이미지를 사용
     - Docker Hub에서 찾은 노드 이미지 이용
       - 이 이미지를 기반으로 하는 컨테이너를 생성



> #### Image

- 디졸버(dissolver) 개념
- 코드와 코드를 실행하는데 필요한 도구들을 포함
- <u>**컨테이너의 템플릿**</u> => 이미지를 기반으로 컨테이너를 실행
- 여러 컨테이너 생성 가능
- 모든 설정과 모든 코드가 포함된 공유 가능한 패키지

🖐이미지는 블루 프린트/템플릿, 템플릿은 코드와 애플리케이션을 포함하며, 컨테이너는 실행 애플리케이션이 됨





> #### 자체 이미지 빌드 실습

- 일반적으로 이미 존재하는 이미지를 기반으로 구축한 다음 자신만의 이미지를 구축
  - ex) 노드 이미지를 구축한 다음 그 이미지로 특정 노드 js 코드를 실행할 수 있음

1. Dockerfile 생성

   - Dockerfile : 도커에 의해 실행되는 특별한 이름
   - 자체 이미지를 빌드할 때 실행하려는 도커에 대한 명령이 포함(자체 이미지에 대한 설정 명령이 포함)

   ```dockerfile
   # FROM (베이스 이미지 이름): 베이스 이미지에 이미지를 구축
   FROM node
   
   # WORKDIR : 도커 컨테이너의 작업 디렉토리를 설정
   WORKDIR /app
   
   # COPY : 도커에게 로컬 머신에 있는 파일이 이미지에 들어가야하는지 알려야 함
   # 첫번째 경로(.) : 컨테이너의 외부, 이미지의 외부 경로이며, 이미지로 복사되어야 할 파일이 있는 곳
   # = Host file System
   # . : 현재 Dockerfile이 있는 디렉토리
   # 두번째 경로(.) : 그 파일을 저장해야하는 이미지 내부의 경로
   # = Image/container file system
   # ./ : 도커 컨테이너의 현재 작업 디렉토리를 의미(WORKDIR 때문에 /app이 됨)
   # COPY . ./
   COPY . /app
   
   # RUN : 이미지가 빌드 될 때마다 실행되는 명령어
   # npm install : 노드 애플리케이션의 모든 종속성 설치
   RUN npm install
   
   # EXPOSE : 컨테이너가 시작될 때, 컨테이너를 실행할 로컬 시스템에 특정 포트를 노출하고 싶다는 것을 도커에게 알림 
   EXPOSE 80
   
   # CMD : 이미지가 생성될 때 실행되지 않고, 이미지를 기반으로 컨테이너가 실행될 때 실행됨
   # 명령어를 배열로 분할
   CMD ["node", "server.js"]
   ```

2. `docker build .` 입력하여 dockerfile을 기반으로 한 이미지를 생성

   - `.` : 도커에게 이 명령을 실행하는 곳과 동일한 폴더에  dockerfile이 존재함을 알림

3. `docker run -p 애플리케이션에 액세스하려는 로컬 포트 지정: 내부 도커 컨테이너 노출 포트 생성된 이미지ID` : 컨테이너 실행

   - -p : 도커에게 어떤 로컬 포트가 있는지 알려줌

4. `docker ps`로 컨테이너 목록 확인

5. `docker stop 컨테이너 이름`을 입력하여 수동으로 종료