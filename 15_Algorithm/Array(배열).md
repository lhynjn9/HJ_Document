# Array(배열)

- 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료 구조



> #### 특징

- 하나의 선언을 통해 둘 이상의 변수 선언이 가능하여 자료에 보다 효율적으로 접근 가능

- 크기가 정해진 배열을 만드는게 속도가 빠를 수 있음  ex) `Arr = [0] * 10`

- 메모리에서 연속된 위치에 저장됨

- 파이썬에서는 리스트로 표현

  

> #### 1차원 배열의 선언

- `Arr = list()`

- `Arr = []`



> #### 1차원 배열의 접근

- `Arr[idx] = n` : 배열 Arr의 idx번 원소에 20을 저장하라는 뜻



> #### 2차원 배열

- 1차원 List를 묶어놓은 List
- 2차원 이상의 다차원 List는 차원에 따라 Index를 선언



> #### 2차원 배열의 선언

- 세로 길이(행의 개수), 가로 길이(열의 개수)를 필요로 함

- `Arr = [[a,b,c],[d,e,f]]`

  - 2행 3열의 2차원 List

    |   a   |   b   |   c   |
    | :---: | :---: | :---: |
    | **d** | **e** | **f** |



> #### 2차원 배열의 접근

- 배열 순회 : n x m 배열의 n*m개의 원소를 빠짐없이 조사하는 방법

- 행 우선 순회

  ```python
  for i in range(n): # i행의 좌표
      for j in range(m): # j열의 좌표
          arr[i][j]
  ```

- 열 우선 순회

  ```python
  for j in range(n): # j열의 좌표
      for i in range(m): # i행의 좌표
          arr[i][j]
  ```

- 지그재그 순회

  ```python
  for i in range(n): # i행의 좌표
      for j in range(m): # j열의 좌표
          arr[i][j + (m-1-2*j) * (i%2)]
  ```

  - 짝수 행일때는 i%2가 0이라 기존 행 우선 순회를

  - 홀수 행일 때는 i%2가 1이므로 m-1부터 0까지 순회해야함

    - 기존 j를 제외시켜주시 위해 -2j를 한 것

      

  > #### 델타를 이용한 2차 배열 탐색

  - 차 배열의 한 좌표에서 4방향(상하좌우)의 인접 배열 요소를 탐색하는 방법

  - **방향의 위치**를 정해주는 것이 가장 중요

    ```python
    arr[0...N-1][0...M-1] # NxM 배열(i, j)
    
    # (1)
    # 4방향의 인덱스에 더해지는 값
    di[] <- [-1, 0, 1, 0] # 상우하좌
    dj[] <- [0, 1, 0, -1] # 상우하좌
    
    for i : 0 -> N-1:
            for j : 0 -> M-1:
                    for k in range(4):
                        # 현재 값 기준으로 값을 이동시킨 결과
                        ni <- i +di[k]
                        nj <- j +dj[k]
                        
                        # 이동한 좌표가 유효한 인덱스에 해당하는지 검사
                        if 0 <= ni < N and 0 <= nj < M:
                            test(arr[ni][nj])
                            
    # (2) : 파이썬의 특성을 이용한 방법
    for i : 0 -> N-1:
            for j : 0 -> M-1:
                for di, dj in [(-1, 0), (0, 1), (1, 0), (0, -1)]:
                    # 현재 값 기준으로 값을 이동시킨 결과
                    ni = i + di
                    nj = j + dj
                    
    				# 이동한 좌표가 유효한 인덱스에 해당하는지 검사
                    if 0 <= ni < N and 0 <= nj < M:
                        test(arr[ni][nj])
    # 결과 : (i, j)좌표와 그 옆에 값이 우하좌상(설정한 순서)에 해당하는 값이 나옴
    ```

    


> ####  2차원 배열의 활용

- 전치 행렬

  - 행과 열의 위치를 바꾼 행렬

  - 좌상단에서 우하단으로 가는 (행과 열의 인덱스가 같은 부분) 대각선은 위치가 변경되지 않음(=이동할 필요가 없음)

    ```python
    # (1)
    # i : 행의 좌표, len(arr)
    # j : 열의 좌표, len(arr[0])
    arr = [[1,2,3], [4,5,6], [7,8,9]] # 3x3행렬
    
    for i in range(3):
        for j in range(3):
            # 우상단은 i < j
            # 좌하단은 i > j
            # i = j는 위치가 변경 되지 않으므로 제외
            if i < j: 
                arr[i][j], arr[j][i] = arr[j][i], arr[i][j]
              
    # (2) : n행에선는 n+1열 ~ N-1열 부분만을 탐색하면 됨
    for i in range(N - 1): # 마지막줄은 좌상단이 없으므로 (N - 1)이 들어감
        for j in range(i + 1, N):
                print(arr[i][j])
    ```

